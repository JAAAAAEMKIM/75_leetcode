주어진 문자열의 
1. substring 중에
2. 중복되는 문자가 없는
3. 가장 긴

substring을 찾아야한다.

가장 먼저 드는 생각은 문자열을 순회하는 index로 start를 잡고,
start부터 중복이 있을 때까지 순회하며 (2중 반복문)
중복이 나오면 max 길이를 체크 후 start 순회를 계속하는 것이다.

여기서 한 가지 포인트를 찾은 것은 abcded 라는 예를 보면, abcded에서 ded 중복을 발견한 순간, b부터 시작하는 문자열, c부터 시작하는 문자열은 ded로 인해서 앞의 abcded보다 짧을 수 밖에 없다. 즉, e부터 다시 순회를 이어가면 된다.

그러기 위해선 문자들의 인덱스를 저장해둘 필요가 있었다.
이를 바탕으로 첫번째 구현을 했다.

이렇게 짠 경우, 시간 내 통과는 하지만 굉장히 느린 것을 알 수 있다.

개선점을 생각해보니, start_(i)에 대한 순회가 끝난 후에 start_(i+1) ~ iter은 중복 체크가 된 구간이므로, 다음 start 순회에서는 start_(i+1) ~ iter 구간에 대한 체크는 필요가 없다는 것이다.

즉, 중복이 발생 하면
start = 중복이 발생한 곳 + 1
iter = iter + 1

이렇게 작성한 경우 중복은 제거되어 O(n)의 알고리즘이 되지만, 반복문을 아직 2회 중첩하여 사용하고 있다.

O(n)이므로 반복문을 잘 구성하면 한개로 줄일 수 있다. 이는 풀이를 보고 찾았다.

cf) sliding window 알고리즘

위 알고리즘은 Sliding window라고 부른다.
