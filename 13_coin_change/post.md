몇년전에 비슷한 유형을 분명 풀어봤었는데, 안 보다 보니 결국 원했던 방식의 답을 찾지 못했다.

처음엔 너무 그리디처럼 보여서 그리디로 풀었는데 정답이 아니었다.

생각해보니 바로 반례가 떠올랐다.

그래서 탐색을 해야하는구나 싶어 dfs를 사용해봤다.

dfs로 풀면 다음과 같다.

푸는 내내 점화식이 떠올랐는데, dfs외의 구현이 떠오르지를 않았다.

https://leetcode.com/problems/coin-change/editorial/
위 에디토리얼을 좀 학습할 필요가 있다.

1. Brute Force

2. DP (Top-down) (내 구현)

3. DP (Bottom-up)

coin 한 개로 가능한 값들을 캐싱해둔 후, 그 캐시를 통해 더 상위의 값들을 계산해나간다.

Top-down 방식과 시간복잡도는 같은데, (O(S*n)) (S: amount, n: coin의 개수)
iteration을 통해 문제를 해결해서 훨씬 빠른 결과가 나오는 것 같다.
